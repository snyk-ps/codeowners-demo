# Hands-on Hacking K8s Workshop | Section 2: Exploit Walk-through

<!-- TOC -->
* [Hands-on Hacking K8s Workshop | Section 2: Exploit Walk-through](#hands-on-hacking-k8s-workshop--section-2--exploit-walk-through)
  * [Part 4: Setting up a beachhead in the cluster](#part-4--setting-up-a-beachhead-in-the-cluster)
    * [Checkpoint](#checkpoint)
      * [What we already knew:](#what-we-already-knew-)
      * [New info:](#new-info-)
      * [Timeline of Doom](#timeline-of-doom)
  * [Next step](#next-step)
<!-- TOC -->

## Part 4: Setting up a beachhead in the cluster

Now that we have Permissions in this secure name space let's see if we can escalate our privileges to break into more areas.
1. First of all, let's exec into the `webadmin` Pod and see what's available to us. Get the Pod name and
   exec into it:
   ```shell
   $ kubectl get pod -n secure
   NAME                        READY   STATUS                       RESTARTS   AGE
   webadmin-69dd65c7f9-hx9cr   1/1     Running                      0          3h37m
   
   $ kubectl exec -n secure -it webadmin-69dd65c7f9-hx9cr -- bash
   webadmin@webadmin-69dd65c7f9-hx9cr:/usr/src/app$
   ```

   
2. Now that we have a shell in the Pod, let's see if we are (or can become) root. Check our user with `whoami`:
   ```shell
   webadmin@webadmin-69dd65c7f9-hx9cr:/usr/src/app$ whoami
   webadmin
   ```
   Not root, but can we become root with `sudo su-`?
   ```shell
   webadmin@webadmin-69dd65c7f9-hx9cr:/usr/src/app$ sudo su -
   bash: sudo: command not found
   ```
   No `sudo`. This tells us the image is better constructed than many default ones as the authors have taken the time
   to change to a non-root user and are not shipping sudo.


3. Let's see if we can make modifications to the filesystem: `touch test`
   ```shell
   webadmin@webadmin-69dd65c7f9-hx9cr:/usr/src/app$ touch test
   
   webadmin@webadmin-69dd65c7f9-hx9cr:/usr/src/app$ ls -l test
   -rw-r--r-- 1 webadmin webadmin 0 Aug 30 18:27 test
   
   webadmin@webadmin-69dd65c7f9-hx9cr:/usr/src/app$ df .
   Filesystem     1K-blocks     Used Available Use% Mounted on
   overlay         61255492 14359844  43754324  25% /
   ```
   We can write to the root filesystem the means we could download software or change configuration.
   We already know we have curl, so that's definitely possible. This is a vulnerability, caused by not
   setting `readonlyRootFilesystem=true` in the Pod SecurityContext and enforcing it in the PSP.

   While this is interesting, it's going to be hard to elevate privileges to root in the Pod so exit out of
   the exec session, and we'll move on for now.


4. Let's try to launch a pod with a root user using the manifest [demo_yamls/root_pod.yaml](../demo_yamls/root_pod.yaml)
   which consists of a container running the `alpine` image that simply sleeps but runs as root by default.

   Deploy the Pod via: `kubectl apply -f demo_yamls/root_pod.yaml -n secure`:
   ```shell
   $ kubectl apply -f demo_yamls/root_pod.yaml -n secure
   Error from server (Forbidden): error when creating "root_pod.yaml": pods "root-pod" is forbidden: violates PodSecurity "restricted:latest": allowPrivilegeEscalation != false (container "justsleep" must set securityContext.allowPrivilegeEscalation=false), unrestricted capabilities (container "justsleep" must set securityContext.capabilities.drop=["ALL"]), runAsNonRoot != true (pod or container "justsleep" must set securityContext.runAsNonRoot=true), seccompProfile (pod or container "justsleep" must set securityContext.seccompProfile.type to "RuntimeDefault" or "Localhost")
   ```
   Failed! ☹️
   
   We can see, from the error, that several "PosSecurity" violations were detected, this error is indicative of Pod Security Admission (PSA) being activated.
   Based on the specific rules cited, this is likely a `Restricted` Pod Security Context policy. This would also preclude starting up a `privileged` container too so let's take a different approach in the next section.

5. Given the PSA restrictions, let's try to deploy our own pod using a container image with tooling to help us explore the cluster.
   The manifest [demo_yamls/nonroot_nonpriv_restricted.yaml](../demo_yamls/nonroot_nonpriv_restricted.yaml) is a Pod that runs our container
   with the proper `securityContext` settings to satisfy PSA. Deploy the Pod via: `kubectl apply -f demo_yamls/nonroot_nonpriv_restricted.yaml -n secure`:
   ```shell
   $ kubectl apply -f nonroot_nonpriv_restricted.yaml -n secure
   pod/snyky created
   ```
6. Now we will exec into our new Pod and see what we can do: `kubectl exec -n secure -it snyky -- bash`
   ```shell
   $ kubectl exec -n secure -it snyky -- bash
   To run a command as administrator (user "root"), use "sudo <command>".
   See "man sudo_root" for details.
   ```
   This image has `sudo` in it, but despite what the login prompt says, if we try to run `sudo ls` we get the following error:
   ```shell
   $ sudo ls
   sudo: The "no new privileges" flag is set, which prevents sudo from running as root.
   sudo: If sudo is running in a container, you may need to adjust the container configuration to disable the flag.
   ```
   This is because the `securityContext` settings in the Pod manifest are set to `allowPrivilegeEscalation: false` to satisfy PSA.

   Side note: On older clusters that still run the obsolete Pod Security Policy restrictions, it often is possible to launch a pod with a non-root user
   but that includes a `sudo` (or other SUID binary) and elevate to root after the pod is running. This is because the Pod SecurityContext default for
   `allowPrivilegeEscalation` is `true` and, unless someone explicitly adds a check for it in their PSP, it will be allowed.

At this point, we don't have root access to the Pod, but we do have a shell in a container using an image our own design so we have our
starting point.


### Checkpoint
Let's take a moment to collect our notes and track our progress.

#### What we already knew:
* An application with an RCE vulnerability is available to us on port 80
* The application is running in a container on a Kubernetes cluster
* The application is behind a service listening on port 5000
* The Kubernetes api-server internal IP address 
* The IP address of the container/pod the application is running in
* The ServiceAccount and Pod configurations in the `secure` Namespace is using the default `automountServiceAccountToken` setting of `true`
* Using a found ServiceAccount token, we were able to connect to the cluster's api-server
* The api-server returned Endpoint information exposing its external IP _(although our workshop Kind cluster obscures this in practice)_
* The account for the token gathered has limited access in the `default` Namespace
* The account is from a Namespace titled `secure` where it has broad access.

#### New info:
* The application container is somewhat hardened by running as a non-root user and its image does not include `sudo`
* The application container is not running with a `readOnlyRootFilesystem:true` so it's mutable
* There are PSA Restricted configurations in place in the `secure` Namespace that restrict root users and privileged mode containers/pods as well as privilege escalation via SUID 

![](media/02-04-Checkpoint-1.png)

#### Timeline of Doom
Updated progress toward total ownership of the target cluster.
![](media/02-04-Timeline-1.png)

## Next step
In the [next step](02e-exploit.md) we try to further explore the cluster and see if any other
targets exist elsewhere in the cluster.
